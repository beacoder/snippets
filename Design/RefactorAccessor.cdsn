// used to express my coding thoughts and
// find the unreasonable logic before we really code.

Code Design:

IHsmCycleAccessor {

+ IHsmCycleAccessor {
  resultPinList

  mHasBuiltCycleAccessors = false;
}

  buildPinCycleAccessor {
  pinName
  pCycleAccessor
}

+ pin {
  pinName

  // checkFailedPinList

  if (!mHasBuiltCycleAccessors)
  {
    std::string failPins = resultPinList;
    std::string::size_type first = 0;
    std::string::size_type end = std::string::npos;

    do
    {
      end = failPins.find_first_of(",", first);
      string pinName = failPins.substr(first, end - first);
      first = end + 1;

      if (pinName.length() == 0)
      {
        break;
      }

      if (mPinAccessorHolder.end() == mPinAccessorHolder.find(pinName))
      {
        mPinAccessorHolder[pinName] = NULL;
      }
      HsmCycleAccessor*& pCycleAccessor = mPinAccessorHolder[pinName];
      if (NULL != pCycleAccessor)
      {
        // in case of re-execution, we need to re-create this.
        delete pCycleAccessor;
        pCycleAccessor = NULL;
      }

      try
      {
        buildPinCycleAccessor(pinName, pCycleAccessor);
      }
      catch (Error & e)
      {
        MsgStream api;
        api << "IHsmCycleAccessor::buildPinCycleAccessor()";
        e.trace() << api.c_str() << Std::endl;
        e.setApi(api.c_str());
        throw (e);
      }

    } while (end != string::npos);

    mHasBuiltCycleAccessors = true;
  }

  if (mPinAccessorHolder.end() != mPinAccessorHolder.find(pinName))
  {
    return mPinAccessorHolder[pinName];
  }

  return NULL;
}

+ std::map<std::string,
  IHsmPinCycleAccessor*> mPinAccessorHolder;

+ bool mHasBuiltCycleAccessors;
}

+ HsmDefaultCycleAccessor {

  HsmDefaultCycleAccessor {
  resultPinList
  execBeginCycle
  numMaxCyclesToUpload
}

  buildPinCycleAccessor {
  pinName
  pCycleAccessor

  LONG64 numMaxCyclesToUpload = mEndCaptureOfLastPattern - mBeginCaptureOfFirstPattern + 1;

  // Non-SMC
  pCycleAccessor =
      new HsmCycleAccessorERMP(pinName,
                               execBeginCycle,
                               numMaxCyclesToUpload);

  std::vector<HsmPattern*> patternHolder;
  for (PatternHolder::const_iterator iter = mPatternHolder.begin();
       iter != mPatternHolder.end();
       ++iter)
  {
    HsmPattern *pPattern = (*iter)->mpImp;
    patternHolder.push_back(pPattern);
  }
}

}

+ HsmSMCCycleAccessor {

  HsmSMCCycleAccessor {
  resultPinList
  resultArea
  std::map<std::string, int> xMode
}

  buildPinCycleAccessor {
  pinName
  pCycleAccessor
  xMode = mXMode[pinName];

  // SMC
  std::string resultArea = mHsmSiteInfo->getResultArea();
  pCycleAccessor =
      new HsmCycleAccessorERMPSMC(pinName,
                                  resultArea,
                                  xMode);
}

  std::map<std::string, int> mXMode;
}

+ HsmOfflineCycleAccessor {

  HsmOfflineCycleAccessor {
  resultPinList
  patternHolder
}

  buildPinCycleAccessor {
  pCycleAccessor =
      new HsmCycleAccessorERMPSimulation(pinName,
                                         patternHolder);
}

}

+ IHsmPinCycleAccessor {

}

+ HsmDefaultPinCycleAccessor {

  HsmDefaultPinCycleAccessor {
  pinName
  execBeginCycle
  numMaxCyclesToUpload
}

}

+ HsmSMCPinCycleAccessor {

  HsmSMCPinCycleAccessor {
  pinName
  resultArea
  xMode
}

}

+ HsmOfflinePinCycleAccessor {

  HsmOfflinePinCycleAccessor {
  pinName
  patternHolder
}

}
