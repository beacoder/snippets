// used to express my coding thoughts and 
// find the unreasonable logic before we really code.
Code Design:

HsmSMCTest {

+ ADBRSetup {
// In the future we could consider passing
// MTP_SERVICE into the DefaultTestDoneListener

// In SMC Mode, what should we pass into the DefaultTestDoneListener ?
resultArea->setTestDoneListener(new DefaultTestDoneListener(HsmSites))
}

}

+ DefaultTestDoneListener {

  DefaultTestDoneListener {
  // for SMC and Non-SMC
  std::map<int ,HsmSite*> sites
}

  testDone {
  // later we'll break this down into several services
  // could extract a method in HsmSite

  // In Non-SMC mode, check if we need to re-execution this
  while (re-execution) {
  HsmSite::generateSiteResults
  }

  // when we finished multiple execution
  HsmSite::generateFailCountResults
  HsmSite::generateRaResults
}

}

ResultAreasCenter {
+ area {
  ResultArea::ResultArea
}

}

HsmPattern {

+ QueryAddressBasedResult {
  ? HsmSiteInfo::mADBRResultIsReady
  <
    NULL
  >
  <
    resultArea->waitAddressBasedResultAvailable
    HsmSiteInfo::mADBRResultIsReady = true
  >
}

  judgeAndLog {
+ QueryAddressBasedResult
}

  generateBitmapFile {
+ QueryAddressBasedResult
}

}

HsmTest {
+ std::string mResultArea
+ bool mADBRResultIsReady

  execute {
+ startTest
+ waitTestDone
+ checkReExecution
  }

+ startTest {
  preExecute
  FunctionalTest::startTest
  adbrSetup
}

+ waitTestDone {
  FunctionalTest::waitTestDone
  generatePassFailResults
  prepareRefreshData
  postExecute
}

+ FunctionalTestSetup {
  resultArea = ResultAreasCenter::area(mResultArea)
  resultArea->wait
  setTestSuiteFlags
  mpPinCardFactory->configureResultMode()
  setupAcquireMode()
  prepareRaExecution()
}

+ HsmTest::ADBRSetup {
  // In the future we could consider passing
  // MTP_SERVICE into the DefaultTestDoneListener
  resultArea->setTestDoneListener(new DefaultTestDoneListener(this))
  setXMode()
}

}

ResultArea {
+ wait {
  // wait if target Result Area is not available yet
  // e.g occupied by other test-suite

  RESULT_AREA_CONFIG_SET::setAsPrimary
}

+ setTestDoneListener

+ startTest {
  acquireExecution
  ::startTest
}

+ waitTestDone {
  ::waitTestDone
  releaseExecution
}

+ onTestDone {
  ITestDoneListner::testDone
}

+ waitAddressBasedResultAvailable {

  // wait for Functional-Test completion
  acquireExecution
  releaseExecution

  onTestDone
}

+ acquireExecution {
  pthread_mutex_lock(&mMutex)
}
+ releaseExecution {
  pthread_mutex_unlock(&mMutex)
}

+ pthread_mutex_t ::mMutex

}
