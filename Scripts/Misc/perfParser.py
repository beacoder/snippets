#!/usr/bin/env python
"""This script is used for parsing perf diff data generated by flamegraph."""

from collections import defaultdict
import re
import argparse

def nested_dict():
    """return a nested_dict."""

    children    = defaultdict(nested_dict)
    children[1] = 0
    children[2] = 0

    return children

class ParserTree(object):
    """Used to store parsed perf data."""

    def __init__(self):
        """used nested_dict as a tree."""

        self._data_ = nested_dict()
        pass

    def insert(self, keys, value1, value2):
        """insert tree data.
e.g: ParseTree.insert([1,2,3], 1, 2) => ParseTree[1][2][3] = (1,2)."""

        ptr  = self._data_
        for key in keys.split(";"):
            ptr    =  ptr[key]
            ptr[1] += value1
            ptr[2] += value2
        pass

    def retrieve(self, keys):
        """get tree data.
e.g: ParseTree.retrieve([1,2,3]) => 1."""

        ptr = self._data_
        for key in keys.split(";"):
            ptr = ptr[key]
        return (ptr[1], ptr[2])
    pass

def process_func_with_subfunc(raw_data):
    """include the subfunctions."""

    tree   = ParserTree()
    for line in raw_data:
        (function, first, second) = line.rsplit(" ", 2)
        tree.insert(function, int(first), int(second))
        print line,
    print

    result = []
    for line in raw_data:
        (function, _, _) = line.rsplit(" ", 2)
        (first, second)  = tree.retrieve(function)
        tmp = "{0} {1} {2}".format(function, str(first), str(second))
        result.append(tmp)
        print tmp
    print
    return result
    
    def count_pencentage(raw_data, outFile):

    threshold_1  = 0.00
    threshold_2  = 0.00

    output_list  = []
    total_counts = 0.00

    # count total counts of first build
    for line in raw_data:
        (_, counts, _) = line.rsplit(" ", 2)
        total_counts += float(counts)

    for line in raw_data:
        (function, first, second) = line.rsplit(" ", 2)

        cmp_to_previous = 0
        cmp_to_total    = 0

        if first == "0" and second == "0":
            continue
        elif first  == "0":
            cmp_to_total = float(second) / float(total_counts)
            first        = "1"
        elif second == "0":
            cmp_to_total = float(first) / float(total_counts)
            second       = "1"
        else:
            cmp_to_total = float(first) / float(total_counts)

        cmp_to_previous = (float(second) - float(first)) / float(first)

        if abs(cmp_to_previous) >= threshold_1 and cmp_to_total > threshold_2:
            tmp = (round(cmp_to_previous, 4), function)
            output_list.append(tmp)
            
    # sort result
    output_list = sorted(output_list, key=lambda item : item[0], reverse=True)

    # output to outfile
    with open(outFile, 'w') as f:
        for line in output_list:
            result = "{0} {1}".format(line[1], line[0])
            f.write("%s\n" % result)
            print result
    pass

def doProcess(fileName, outFile, include_subfunc):
    raw_data = [x for x in open(fileName)]

    if include_subfunc:
        raw_data = process_func_with_subfunc(raw_data)

    count_pencentage(raw_data, outFile)

    # used as a pause
    # raw_input()
    # import pdb
    # pdb.set_trace()
    pass

def createParser():
    ap = argparse.ArgumentParser()
    ap.add_argument("-f")
    ap.add_argument("-o")
    ap.add_argument("-i", "--includeSubFunc", required=False)

    return ap.parse_args()
    
def usage():
    sample ="""Parsing perf diff data generated by flamegraph:

Usage: ./perfParser.py -f ~/diff.data -o ~/diff.output -i anything
  """
    print sample

def main():
    args = createParser()
    if args.f and args.o:
        if args.includeSubFunc is not None:
            doProcess(args.f, args.o, True)
        else:
            doProcess(args.f, args.o, False)
    else:
        usage()
    pass


if __name__ == "__main__":
    main()
